# æœ¬åœ°åŒ–SubagentæŠ€èƒ½æ¡Œé¢åº”ç”¨ - æŠ€æœ¯è®¾è®¡æ–‡æ¡£

## ğŸ“‹ è®¾è®¡æ¦‚è¿°

### è®¾è®¡ç›®æ ‡
åˆ›å»ºä¸€ä¸ªæ™ºèƒ½åŒ–çš„æœ¬åœ°åŒ–å›¾å½¢ç•Œé¢åº”ç”¨ï¼Œç”¨æˆ·é€šè¿‡ç›´è§‚çš„ç•Œé¢è¾“å…¥éœ€æ±‚ï¼Œåå°é€šè¿‡æœ¬åœ°éƒ¨ç½²çš„Stigmergyå’Œå„ä¸ªAI CLIå·¥å…·è¿›è¡Œè°ƒç”¨ï¼Œå®ç°æ™ºèƒ½ä½“åä½œå’ŒæŠ€èƒ½å¤„ç†ï¼Œæœ€ç»ˆå°†ç»“æœè¾“å‡ºåˆ°ç”¨æˆ·ç•Œé¢ã€‚åœ¨AIäº’åŠ¨è¿‡ç¨‹ä¸­ï¼Œç”¨æˆ·å¯ä»¥ç›´æ¥åˆ›å»ºé¡¹ç›®ç›®å½•ã€ç®¡ç†æ–‡ä»¶ã€ç¼–è¾‘å†…å®¹ï¼Œå½¢æˆå®Œæ•´çš„AIè¾…åŠ©å¼€å‘ç¯å¢ƒã€‚æ‰€æœ‰AIè°ƒç”¨å’Œæ–‡ä»¶æ“ä½œéƒ½åœ¨æœ¬åœ°å®Œæˆï¼Œç¡®ä¿æ•°æ®éšç§å’Œå¤„ç†ç‹¬ç«‹æ€§ã€‚

### è®¾è®¡åŸåˆ™
- **ç”¨æˆ·äº¤äº’ä¼˜å…ˆ**ï¼šæä¾›ç›´è§‚ã€å‹å¥½çš„å›¾å½¢ç•Œé¢ï¼Œé™ä½AIä½¿ç”¨é—¨æ§›
- **æœ¬åœ°åŒ–éƒ¨ç½²ä¼˜å…ˆ**ï¼šæ‰€æœ‰AIè°ƒç”¨åŸºäºæœ¬åœ°éƒ¨ç½²çš„Stigmergyå’ŒCLIå·¥å…·
- **é¡¹ç›®æ–‡ä»¶ç®¡ç†**ï¼šåœ¨AIäº’åŠ¨ä¸­æ”¯æŒå®Œæ•´çš„é¡¹ç›®å’Œæ–‡ä»¶æ“ä½œ
- **æ™ºèƒ½è·¯ç”±æœºåˆ¶**ï¼šé€šè¿‡æœ¬åœ°Stigmergyè‡ªåŠ¨é€‰æ‹©æœ€åˆé€‚çš„AI CLIå’ŒæŠ€èƒ½
- **æ•°æ®éšç§ä¿æŠ¤**ï¼šæ‰€æœ‰AIå¤„ç†å’Œæ–‡ä»¶æ“ä½œéƒ½åœ¨æœ¬åœ°å®Œæˆï¼Œä¸ä¾èµ–äº‘ç«¯æœåŠ¡
- **å®æ—¶åä½œæ”¯æŒ**ï¼šæ”¯æŒå¤šä¸ªæœ¬åœ°AIå’Œæ™ºèƒ½ä½“çš„å®æ—¶åä½œå’Œæ•°æ®ä¼ é€’
- **ç»“æœå¯è§†åŒ–**ï¼šå°†AIå¤„ç†ç»“æœä»¥ç›´è§‚çš„æ–¹å¼å‘ˆç°ç»™ç”¨æˆ·
- **æŒç»­äº¤äº’è®¾è®¡**ï¼šæ”¯æŒç”¨æˆ·ä¸AIçš„æŒç»­å¯¹è¯å’Œè¿­ä»£ä¼˜åŒ–

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾ (æ™ºèƒ½äº¤äº’æ¶æ„)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Electronæ¡Œé¢åº”ç”¨ (æ™ºèƒ½äº¤äº’æ¶æ„)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç”¨æˆ·ç•Œé¢å±‚ (Reactæ™ºèƒ½äº¤äº’ç•Œé¢)                                â”‚
â”‚  â”œâ”€â”€ éœ€æ±‚è¾“å…¥ç•Œé¢                                            â”‚
â”‚  â”‚   â”œâ”€â”€ è‡ªç„¶è¯­è¨€è¾“å…¥æ¡† (æ”¯æŒæ–‡æœ¬/æ–‡ä»¶ä¸Šä¼ )                   â”‚
â”‚  â”‚   â”œâ”€â”€ ä»»åŠ¡ç±»å‹é€‰æ‹© (åˆ†æ/ç¼–ç¨‹/å†™ä½œ/ç ”ç©¶ç­‰)                 â”‚
â”‚  â”‚   â”œâ”€â”€ å‚æ•°é…ç½®é¢æ¿ (è®¾ç½®å¤„ç†å‚æ•°å’Œè¾“å‡ºæ ¼å¼)                 â”‚
â”‚  â”‚   â””â”€â”€ å†å²è®°å½•æŸ¥çœ‹ (æŸ¥çœ‹ä¹‹å‰çš„äº¤äº’è®°å½•)                     â”‚
â”‚  â”œâ”€â”€ æŠ€èƒ½ç®¡ç†ç•Œé¢                                            â”‚
â”‚  â”‚   â”œâ”€â”€ æŠ€èƒ½ä¸Šä¼ åŠŸèƒ½ (æ‹–æ‹½ä¸Šä¼ /æ–‡ä»¶é€‰æ‹©/URLä¸‹è½½)              â”‚
â”‚  â”‚   â”œâ”€â”€ æŠ€èƒ½å®‰è£…åŠŸèƒ½ (ä¸€é”®å®‰è£…/æ‰¹é‡å®‰è£…/ä¾èµ–æ£€æŸ¥)              â”‚
â”‚  â”‚   â”œâ”€â”€ æŠ€èƒ½é…ç½®åŠŸèƒ½ (å‚æ•°è®¾ç½®/å¯ç”¨ç¦ç”¨/ä¼˜å…ˆçº§)               â”‚
â”‚  â”‚   â”œâ”€â”€ æŠ€èƒ½å¸‚åœºåŠŸèƒ½ (æµè§ˆ/æœç´¢/è¯„ä»·æŠ€èƒ½)                    â”‚
â”‚  â”‚   â””â”€â”€ æŠ€èƒ½ç›‘æ§åŠŸèƒ½ (çŠ¶æ€ç›‘æ§/ç‰ˆæœ¬ç®¡ç†/è‡ªåŠ¨æ›´æ–°)             â”‚
â”‚  â”œâ”€â”€ é¡¹ç›®ç®¡ç†ç•Œé¢                                            â”‚
â”‚  â”‚   â”œâ”€â”€ é¡¹ç›®åˆ›å»ºåŠŸèƒ½ (åŸºäºAIå»ºè®®åˆ›å»ºé¡¹ç›®ç»“æ„)                  â”‚
â”‚  â”‚   â”œâ”€â”€ ç›®å½•æ ‘å±•ç¤º (å®æ—¶æ˜¾ç¤ºé¡¹ç›®æ–‡ä»¶ç»“æ„)                     â”‚
â”‚  â”‚   â”œâ”€â”€ æ–‡ä»¶æ“ä½œåŠŸèƒ½ (åˆ›å»º/åˆ é™¤/é‡å‘½å/å¤åˆ¶/ç§»åŠ¨)               â”‚
â”‚  â”‚   â”œâ”€â”€ æ–‡ä»¶ç¼–è¾‘åŠŸèƒ½ (é›†æˆä»£ç ç¼–è¾‘å™¨ï¼Œæ”¯æŒè¯­æ³•é«˜äº®)           â”‚
â”‚  â”‚   â”œâ”€â”€ ç‰ˆæœ¬æ§åˆ¶åŠŸèƒ½ (Gité›†æˆï¼Œæ”¯æŒæäº¤/åˆ†æ”¯/åˆå¹¶)              â”‚
â”‚  â”‚   â””â”€â”€ é¡¹ç›®æ¨¡æ¿åŠŸèƒ½ (æä¾›å¸¸ç”¨é¡¹ç›®æ¨¡æ¿å¿«é€Ÿåˆå§‹åŒ–)               â”‚
â”‚  â”œâ”€â”€ å®æ—¶å¤„ç†ç•Œé¢                                             â”‚
â”‚  â”‚   â”œâ”€â”€ ä»»åŠ¡çŠ¶æ€æ˜¾ç¤º (å®æ—¶æ˜¾ç¤ºAIå¤„ç†è¿›åº¦)                    â”‚
â”‚  â”‚   â”œâ”€â”€ åä½œæµç¨‹å¯è§†åŒ– (æ˜¾ç¤ºAIä¹‹é—´çš„åä½œå…³ç³»)                 â”‚
â”‚  â”‚   â”œâ”€â”€ ä¸­é—´ç»“æœå±•ç¤º (æ˜¾ç¤ºå¤„ç†è¿‡ç¨‹ä¸­çš„ä¸­é—´ç»“æœ)               â”‚
â”‚  â”‚   â””â”€â”€ é”™è¯¯æç¤ºå’Œé‡è¯• (å¤„ç†å¼‚å¸¸æƒ…å†µ)                        â”‚
â”‚  â”œâ”€â”€ ç»“æœå±•ç¤ºç•Œé¢                                             â”‚
â”‚  â”‚   â”œâ”€â”€ ç»“æœå¯è§†åŒ– (å›¾è¡¨/è¡¨æ ¼/æ–‡æœ¬ç­‰å¤šç§å½¢å¼)                 â”‚
â”‚  â”‚   â”œâ”€â”€ ç»“æœåˆ†æè§£è¯» (AIå¯¹ç»“æœçš„è§£é‡Šå’Œå»ºè®®)                   â”‚
â”‚  â”‚   â”œâ”€â”€ ç»“æœå¯¼å‡ºåŠŸèƒ½ (æ”¯æŒå¤šç§æ ¼å¼å¯¼å‡º)                      â”‚
â”‚  â”‚   â””â”€â”€ ç»“æœåˆ†äº«åŠŸèƒ½ (åˆ†äº«ç»™å…¶ä»–ç”¨æˆ·æˆ–å¹³å°)                   â”‚
â”‚  â””â”€â”€ äº¤äº’æ§åˆ¶ç•Œé¢                                             â”‚
â”‚      â”œâ”€â”€ ç»§ç»­å¯¹è¯ (åŸºäºå½“å‰ç»“æœç»§ç»­æé—®)                       â”‚
â”‚      â”œâ”€â”€ ä¿®æ”¹å‚æ•° (è°ƒæ•´å¤„ç†å‚æ•°é‡æ–°å¤„ç†)                       â”‚
â”‚      â”œâ”€â”€ åˆ‡æ¢AI (é€‰æ‹©ä¸åŒçš„AIå·¥å…·å¤„ç†)                         â”‚
â”‚      â””â”€â”€ ä¿å­˜ä¼šè¯ (ä¿å­˜å½“å‰äº¤äº’çŠ¶æ€)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¥å£å±‚ (Node.js CLIåŒ…è£…å’Œæ–‡ä»¶æ“ä½œ)                           â”‚
â”‚  â”œâ”€â”€ Stigmergy CLIåŒ…è£…å™¨                                     â”‚
â”‚  â”‚   â”œâ”€â”€ å‘½ä»¤æ‰§è¡Œå™¨ (è°ƒç”¨stigmergyå‘½ä»¤)                     â”‚
â”‚  â”‚   â”œâ”€â”€ è¾“å‡ºè§£æå™¨ (è§£æstigmergyè¾“å‡º)                     â”‚
â”‚  â”‚   â”œâ”€â”€ é”™è¯¯å¤„ç†å™¨ (å¤„ç†å‘½ä»¤æ‰§è¡Œé”™è¯¯)                       â”‚
â”‚  â”‚   â””â”€â”€ è¿›åº¦ç›‘æ§å™¨ (ç›‘æ§å‘½ä»¤æ‰§è¡Œè¿›åº¦)                       â”‚
â”‚  â”œâ”€â”€ CLIé…ç½®æ–‡ä»¶æ“ä½œå™¨                                         â”‚
â”‚  â”‚   â”œâ”€â”€ é…ç½®è¯»å–å™¨ (è¯»å–CLIé…ç½®æ–‡ä»¶)                       â”‚
â”‚  â”‚   â”œâ”€â”€ é…ç½®å†™å…¥å™¨ (å†™å…¥CLIé…ç½®æ–‡ä»¶)                       â”‚
â”‚  â”‚   â”œâ”€â”€ é…ç½®éªŒè¯å™¨ (éªŒè¯é…ç½®æ–‡ä»¶æ ¼å¼)                       â”‚
â”‚  â”‚   â””â”€â”€ å¤‡ä»½ç®¡ç†å™¨ (é…ç½®æ–‡ä»¶å¤‡ä»½å’Œæ¢å¤)                     â”‚
â”‚  â”œâ”€â”€ æŠ€èƒ½æ–‡ä»¶ç®¡ç†å™¨                                           â”‚
â”‚  â”‚   â”œâ”€â”€ æ–‡ä»¶å¤åˆ¶å™¨ (å¤åˆ¶æŠ€èƒ½åˆ°CLIç›®å½•)                     â”‚
â”‚  â”‚   â”œâ”€â”€ æ–‡ä»¶åˆ é™¤å™¨ (ä»CLIç›®å½•åˆ é™¤æŠ€èƒ½)                     â”‚
â”‚  â”‚   â”œâ”€â”€ ç›®å½•æ‰«æå™¨ (æ‰«ææŠ€èƒ½ç›®å½•ç»“æ„)                       â”‚
â”‚  â”‚   â””â”€â”€ å˜æ›´ç›‘æ§å™¨ (ç›‘æ§æŠ€èƒ½æ–‡ä»¶å˜åŒ–)                       â”‚
â”‚  â””â”€â”€ å®æ—¶åŒæ­¥ç›‘æ§å™¨                                           â”‚
â”‚      â”œâ”€â”€ æ–‡ä»¶ç›‘æ§ (ç›‘æ§é…ç½®æ–‡ä»¶å˜åŒ–)                         â”‚
â”‚      â”œâ”€â”€ çŠ¶æ€åŒæ­¥ (åŒæ­¥ç•Œé¢å’Œæ–‡ä»¶çŠ¶æ€)                       â”‚
â”‚      â”œâ”€â”€ äº‹ä»¶åˆ†å‘ (åˆ†å‘å˜æ›´äº‹ä»¶)                             â”‚
â”‚      â””â”€â”€ å†²çªå¤„ç† (å¤„ç†å¹¶å‘æ“ä½œå†²çª)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ•°æ®å±‚ (æœ¬åœ°æ•°æ®ç®¡ç†)                                       â”‚
â”‚  â”œâ”€â”€ æŠ€èƒ½ä¿¡æ¯ç¼“å­˜ (SQLiteæ•°æ®åº“)                              â”‚
â”‚  â”‚   â”œâ”€â”€ æŠ€èƒ½å…ƒæ•°æ®ç¼“å­˜                                       â”‚
â”‚  â”‚   â”œâ”€â”€ æŠ€èƒ½ä¾èµ–å…³ç³»ç¼“å­˜                                     â”‚
â”‚  â”‚   â””â”€â”€ æŠ€èƒ½çŠ¶æ€ç¼“å­˜                                         â”‚
â”‚  â”œâ”€â”€ ç”¨æˆ·æ“ä½œå†å² (SQLiteæ•°æ®åº“)                              â”‚
â”‚  â”‚   â”œâ”€â”€ æ“ä½œè®°å½•                                             â”‚
â”‚  â”‚   â”œâ”€â”€ æ’¤é”€/é‡åšæ”¯æŒ                                       â”‚
â”‚  â”‚   â””â”€â”€ æ“ä½œç»Ÿè®¡åˆ†æ                                       â”‚
â”‚  â””â”€â”€ ç•Œé¢é…ç½®å­˜å‚¨ (JSONæ–‡ä»¶)                                 â”‚
â”‚      â”œâ”€â”€ ç”¨æˆ·åå¥½è®¾ç½®                                         â”‚
â”‚      â”œâ”€â”€ ç•Œé¢å¸ƒå±€é…ç½®                                         â”‚
â”‚      â””â”€â”€ ä¸»é¢˜å’Œæ ·å¼é…ç½®                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é›†æˆå±‚ (ä¸ç°æœ‰ç³»ç»Ÿæ·±åº¦é›†æˆ)                                 â”‚
â”‚  â”œâ”€â”€ Stigmergy CLIé›†æˆ                                       â”‚
â”‚  â”‚   â”œâ”€â”€ å®Œæ•´å‘½ä»¤æ”¯æŒ (æ”¯æŒæ‰€æœ‰stigmergyå‘½ä»¤)                â”‚
â”‚  â”‚   â”œâ”€â”€ è¾“å‡ºæ ¼å¼è§£æ (è§£æå‘½ä»¤è¾“å‡ºæ ¼å¼)                     â”‚
â”‚  â”‚   â””â”€â”€ é”™è¯¯ä¿¡æ¯å¤„ç† (å¤„ç†CLIé”™è¯¯ä¿¡æ¯)                       â”‚
â”‚  â”œâ”€â”€ å¤šCLIé…ç½®é›†æˆ                                             â”‚
â”‚  â”‚   â”œâ”€â”€ Claudeé…ç½®é›†æˆ (~/.claude/)                        â”‚
â”‚  â”‚   â”œâ”€â”€ Qwené…ç½®é›†æˆ (~/.qwen/)                            â”‚
â”‚  â”‚   â”œâ”€â”€ iFlowé…ç½®é›†æˆ (~/.iflow/)                           â”‚
â”‚  â”‚   â””â”€â”€ å…¶ä»–CLIé…ç½®é›†æˆ                                      â”‚
â”‚  â”œâ”€â”€ æŠ€èƒ½ç³»ç»Ÿé›†æˆ                                             â”‚
â”‚  â”‚   â”œâ”€â”€ ç°æœ‰éƒ¨ç½²æœºåˆ¶åˆ©ç”¨ (åˆ©ç”¨scripts/deploy-*.js)          â”‚
â”‚  â”‚   â”œâ”€â”€ æŠ€èƒ½ç›®å½•ç®¡ç† (ç®¡ç†skills/ç›®å½•)                      â”‚
â”‚  â”‚   â””â”€â”€ æŠ€èƒ½æ–‡ä»¶æ“ä½œ (å¤åˆ¶/åˆ é™¤/æ›´æ–°æŠ€èƒ½æ–‡ä»¶)               â”‚
â”‚  â””â”€â”€ åä½œç³»ç»Ÿé›†æˆ                                             â”‚
â”‚      â”œâ”€â”€ è·¨CLIè°ƒç”¨æ”¯æŒ (æ”¯æŒstigmergy use/call)              â”‚
â”‚      â”œâ”€â”€ åä½œæµç¨‹æ„å»º (æ„å»ºå¤æ‚åä½œæµç¨‹)                     â”‚
â”‚      â””â”€â”€ åä½œçŠ¶æ€ç›‘æ§ (ç›‘æ§åä½œæ‰§è¡ŒçŠ¶æ€)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 1. æŠ€èƒ½ç®¡ç†å™¨
```javascript
// æŠ€èƒ½ç®¡ç†å™¨ - å®Œæ•´çš„æŠ€èƒ½ç”Ÿå‘½å‘¨æœŸç®¡ç†
class SkillManager {
  constructor() {
    this.stigmergyWrapper = new StigmergyCLIWrapper();
    this.fileManager = new SkillFileManager();
    this.configManager = new SkillConfigManager();
  }

  // æŠ€èƒ½ä¸Šä¼ åŠŸèƒ½
  async uploadSkill(source, options = {}) {
    try {
      let skillPath;
      
      if (source.type === 'file') {
        // æ–‡ä»¶ä¸Šä¼ 
        skillPath = await this.fileManager.saveUploadedFile(source.file);
      } else if (source.type === 'url') {
        // URLä¸‹è½½
        skillPath = await this.fileManager.downloadFromURL(source.url);
      } else if (source.type === 'github') {
        // GitHubä»“åº“ä¸‹è½½
        skillPath = await this.fileManager.cloneFromGitHub(source.repo);
      }
      
      // éªŒè¯æŠ€èƒ½æ ¼å¼
      const validation = await this.validateSkill(skillPath);
      if (!validation.valid) {
        throw new Error(`æŠ€èƒ½éªŒè¯å¤±è´¥: ${validation.errors.join(', ')}`);
      }
      
      return {
        success: true,
        skillPath: skillPath,
        metadata: validation.metadata
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // æŠ€èƒ½å®‰è£…åŠŸèƒ½
  async installSkill(skillPath, targetCLIs = []) {
    try {
      // æ£€æŸ¥æŠ€èƒ½ä¾èµ–
      const dependencies = await this.checkDependencies(skillPath);
      
      // å®‰è£…ä¾èµ–
      for (const dep of dependencies) {
        await this.installDependency(dep);
      }
      
      // å®‰è£…åˆ°Stigmergy
      const stigmergyResult = await this.stigmergyWrapper.installSkill(skillPath);
      
      // åŒæ­¥åˆ°å„ä¸ªCLI
      const syncResults = [];
      for (const cli of targetCLIs) {
        const result = await this.stigmergyWrapper.syncSkills(cli);
        syncResults.push({ cli, result });
      }
      
      return {
        success: true,
        stigmergyResult: stigmergyResult,
        syncResults: syncResults,
        dependencies: dependencies
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // æŠ€èƒ½é…ç½®åŠŸèƒ½
  async configureSkill(skillName, config, targetCLIs = []) {
    try {
      const results = [];
      
      for (const cli of targetCLIs) {
        // æ›´æ–°CLIé…ç½®æ–‡ä»¶
        const result = await this.configManager.updateSkillConfig(cli, skillName, config);
        results.push({ cli, result });
      }
      
      // æ›´æ–°Stigmergyé…ç½®
      const stigmergyResult = await this.configManager.updateStigmergyConfig(skillName, config);
      
      return {
        success: true,
        results: results,
        stigmergyResult: stigmergyResult
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // æŠ€èƒ½å¯ç”¨/ç¦ç”¨
  async toggleSkill(skillName, enabled, targetCLIs = []) {
    return await this.configureSkill(skillName, { enabled }, targetCLIs);
  }

  // æ‰¹é‡æŠ€èƒ½æ“ä½œ
  async batchOperation(operation, skills, options = {}) {
    const results = [];
    
    for (const skill of skills) {
      let result;
      
      switch (operation) {
        case 'install':
          result = await this.installSkill(skill.path, options.targetCLIs);
          break;
        case 'configure':
          result = await this.configureSkill(skill.name, skill.config, options.targetCLIs);
          break;
        case 'enable':
          result = await this.toggleSkill(skill.name, true, options.targetCLIs);
          break;
        case 'disable':
          result = await this.toggleSkill(skill.name, false, options.targetCLIs);
          break;
        default:
          result = { success: false, error: `ä¸æ”¯æŒçš„æ“ä½œ: ${operation}` };
      }
      
      results.push({
        skill: skill.name || skill.path,
        result: result
      });
    }
    
    return results;
  }

  // éªŒè¯æŠ€èƒ½æ ¼å¼
  async validateSkill(skillPath) {
    try {
      const skillFile = path.join(skillPath, 'SKILL.md');
      
      if (!await fs.pathExists(skillFile)) {
        return { valid: false, errors: ['ç¼ºå°‘SKILL.mdæ–‡ä»¶'] };
      }
      
      const content = await fs.readFile(skillFile, 'utf8');
      
      // æ£€æŸ¥YAML frontmatter
      const frontmatterMatch = content.match(/^---\s*\n([\s\S]*?)\n---/);
      if (!frontmatterMatch) {
        return { valid: false, errors: ['ç¼ºå°‘YAML frontmatter'] };
      }
      
      const frontmatter = frontmatterMatch[1];
      const metadata = this.parseYamlFrontmatter(frontmatter);
      
      // éªŒè¯å¿…éœ€å­—æ®µ
      const errors = [];
      if (!metadata.name) errors.push('ç¼ºå°‘nameå­—æ®µ');
      if (!metadata.description) errors.push('ç¼ºå°‘descriptionå­—æ®µ');
      
      return {
        valid: errors.length === 0,
        errors: errors,
        metadata: metadata
      };
    } catch (error) {
      return { valid: false, errors: [error.message] };
    }
  }

  // æ£€æŸ¥æŠ€èƒ½ä¾èµ–
  async checkDependencies(skillPath) {
    const skillFile = path.join(skillPath, 'SKILL.md');
    const content = await fs.readFile(skillFile, 'utf8');
    
    // è§£æä¾èµ–å…³ç³»
    const dependencies = [];
    const depMatch = content.match(/dependencies:\s*\n([\s\S]*?)(?=\n\w+:|$)/);
    
    if (depMatch) {
      const depLines = depMatch[1].split('\n').filter(line => line.trim());
      for (const line of depLines) {
        const dep = line.trim().replace(/^-\s*/, '');
        if (dep) dependencies.push(dep);
      }
    }
    
    return dependencies;
  }

  // å®‰è£…ä¾èµ–
  async installDependency(dependency) {
    // å®ç°ä¾èµ–å®‰è£…é€»è¾‘
    return await this.stigmergyWrapper.installSkill(dependency);
  }

  // è§£æYAML frontmatter
  parseYamlFrontmatter(frontmatter) {
    const metadata = {};
    const lines = frontmatter.split('\n');
    
    for (const line of lines) {
      const match = line.match(/^(\w+):\s*(.+)$/);
      if (match) {
        metadata[match[1]] = match[2].trim();
      }
    }
    
    return metadata;
  }
}
```

#### 2. å®‰å…¨æ‰§è¡Œæœºåˆ¶ (å®Œå…¨ç»§æ‰¿Open Interpreter)
```javascript
// ç›´æ¥ç»§æ‰¿Open Interpreterçš„SafeExecutor
class SafeExecutor extends OpenInterpreterSafeExecutor {
  constructor() {
    super();
    // å®Œå…¨é‡‡ç”¨Open Interpreterçš„é…ç½®
    this.allowedCommands = [
      'stigmergy', 'iflow', 'claude', 'qwen', 'gemini', 'iflow',
      'codebuddy', 'codex', 'qodercli', 'python'
    ];
    this.executionTimeout = 30000;
    this.securityPatterns = this.loadOpenInterpreterPatterns();
  }

  // å®Œå…¨ç»§æ‰¿Open Interpreterçš„éªŒè¯é€»è¾‘
  async validate(command, args) {
    // ç›´æ¥ä½¿ç”¨Open Interpreterçš„éªŒè¯æ–¹æ³•
    return await this.performOpenInterpreterValidation(command, args);
  }

  // å®Œå…¨ç»§æ‰¿Open Interpreterçš„æ‰§è¡Œé€»è¾‘
  async execute(command, args) {
    // ç›´æ¥ä½¿ç”¨Open Interpreterçš„æ‰§è¡Œæ–¹æ³•
    return await this.performOpenInterpreterExecution(command, args);
  }

  // ç»§æ‰¿Open Interpreterçš„å®‰å…¨æ¨¡å¼
  loadOpenInterpreterPatterns() {
    // ç›´æ¥ä½¿ç”¨Open Interpreterçš„å®‰å…¨æ¨¡å¼é…ç½®
    return this.getOpenInterpreterSecurityPatterns();
  }
}
```

#### 3. æ’ä»¶ç³»ç»Ÿ (å®Œå…¨ç»§æ‰¿Continueæ¶æ„)
```typescript
// ç›´æ¥ç»§æ‰¿Continueçš„æ’ä»¶ç³»ç»Ÿ
class StigmergyPluginSystem extends ContinuePluginSystem {
  constructor() {
    super();
    // å®Œå…¨é‡‡ç”¨Continueçš„æ’ä»¶æ¶æ„
    this.pluginRegistry = new ContinuePluginRegistry();
    this.pluginLoader = new ContinuePluginLoader();
    this.permissionManager = new ContinuePermissionManager();
  }

  // å®Œå…¨ç»§æ‰¿Continueçš„æ’ä»¶åŠ è½½æœºåˆ¶
  async loadPlugin(pluginPath: string): Promise<void> {
    // ç›´æ¥ä½¿ç”¨Continueçš„æ’ä»¶åŠ è½½æ–¹æ³•
    return await this.performContinuePluginLoad(pluginPath);
  }

  // å®Œå…¨ç»§æ‰¿Continueçš„æ’ä»¶å¸è½½æœºåˆ¶
  async unloadPlugin(pluginName: string): void {
    // ç›´æ¥ä½¿ç”¨Continueçš„æ’ä»¶å¸è½½æ–¹æ³•
    return await this.performContinuePluginUnload(pluginName);
  }

  // å®Œå…¨ç»§æ‰¿Continueçš„æ’ä»¶æ‰§è¡Œæœºåˆ¶
  async executePlugin(pluginName: string, method: string, ...args: any[]): any {
    // ç›´æ¥ä½¿ç”¨Continueçš„æ’ä»¶æ‰§è¡Œæ–¹æ³•
    return await this.performContinuePluginExecution(pluginName, method, ...args);
  }

  // æ–°å¢StigmergyæŠ€èƒ½æ’ä»¶åŠ è½½
  async loadStigmergySkillsAsPlugins() {
    const skillsDir = path.join(__dirname, '../skills');
    const skillFolders = await fs.readdir(skillsDir);

    for (const folder of skillFolders) {
      const skillPath = path.join(skillsDir, folder);
      if (fs.statSync(skillPath).isDirectory()) {
        await this.loadStigmergySkillPlugin(skillPath);
      }
    }
  }

  private async loadStigmergySkillPlugin(skillPath: string): Promise<void> {
    // ä½¿ç”¨Continueçš„æ’ä»¶æ¥å£åŒ…è£…StigmergyæŠ€èƒ½
    const skillPlugin = await this.createContinuePluginFromSkill(skillPath);
    await this.loadPlugin(skillPlugin);
  }
}
```

#### 4. æ•°æ®å­˜å‚¨è®¾è®¡
```sql
-- SQLiteæ•°æ®åº“è®¾è®¡
-- ä¼šè¯è¡¨
CREATE TABLE sessions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  metadata TEXT -- JSONæ ¼å¼å­˜å‚¨ä¼šè¯å…ƒæ•°æ®
);

-- æŠ€èƒ½ä½¿ç”¨è®°å½•è¡¨
CREATE TABLE skill_usage (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id INTEGER,
  skill_name TEXT NOT NULL,
  command TEXT NOT NULL,
  result TEXT,
  executed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (session_id) REFERENCES sessions (id)
);

-- é¡¹ç›®æ–‡ä»¶è¡¨
CREATE TABLE project_files (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  project_path TEXT NOT NULL,
  file_path TEXT NOT NULL,
  file_type TEXT,
  last_modified DATETIME,
  metadata TEXT -- JSONæ ¼å¼å­˜å‚¨æ–‡ä»¶å…ƒæ•°æ®
);

-- CLIé…ç½®è¡¨
CREATE TABLE cli_configs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  cli_name TEXT NOT NULL UNIQUE,
  config_path TEXT NOT NULL,
  is_enabled BOOLEAN DEFAULT TRUE,
  priority INTEGER DEFAULT 0
);
```

---

## ğŸ¨ å‰ç«¯è®¾è®¡

### Reactç»„ä»¶æ¶æ„
```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ Layout.jsx          # ä¸»å¸ƒå±€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ Sidebar.jsx         # ä¾§è¾¹æ ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ Header.jsx          # å¤´éƒ¨ç»„ä»¶
â”‚   â”‚   â””â”€â”€ Loading.jsx         # åŠ è½½ç»„ä»¶
â”‚   â”œâ”€â”€ skills/
â”‚   â”‚   â”œâ”€â”€ SkillList.jsx       # æŠ€èƒ½åˆ—è¡¨
â”‚   â”‚   â”œâ”€â”€ SkillCard.jsx       # æŠ€èƒ½å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ SkillDetail.jsx     # æŠ€èƒ½è¯¦æƒ…
â”‚   â”‚   â””â”€â”€ SkillExecutor.jsx   # æŠ€èƒ½æ‰§è¡Œå™¨
â”‚   â”œâ”€â”€ cli/
â”‚   â”‚   â”œâ”€â”€ CLIStatus.jsx       # CLIçŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ CrossCLIExecutor.jsx # è·¨CLIæ‰§è¡Œå™¨
â”‚   â”‚   â””â”€â”€ CLIConfig.jsx       # CLIé…ç½®
â”‚   â”œâ”€â”€ project/
â”‚   â”‚   â”œâ”€â”€ ProjectTree.jsx     # é¡¹ç›®æ–‡ä»¶æ ‘
â”‚   â”‚   â”œâ”€â”€ FilePreview.jsx     # æ–‡ä»¶é¢„è§ˆ
â”‚   â”‚   â””â”€â”€ ProjectMonitor.jsx  # é¡¹ç›®ç›‘æ§
â”‚   â””â”€â”€ session/
â”‚       â”œâ”€â”€ SessionList.jsx     # ä¼šè¯åˆ—è¡¨
â”‚       â”œâ”€â”€ SessionDetail.jsx   # ä¼šè¯è¯¦æƒ…
â”‚       â””â”€â”€ SessionRestore.jsx  # ä¼šè¯æ¢å¤
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useCLI.js               # CLIè°ƒç”¨Hook
â”‚   â”œâ”€â”€ useSkills.js            # æŠ€èƒ½ç®¡ç†Hook
â”‚   â”œâ”€â”€ useSessions.js          # ä¼šè¯ç®¡ç†Hook
â”‚   â””â”€â”€ useProjects.js          # é¡¹ç›®ç®¡ç†Hook
â”œâ”€â”€ store/
â”‚   â”œâ”€â”€ index.js                # çŠ¶æ€ç®¡ç†å…¥å£
â”‚   â”œâ”€â”€ slices/
â”‚   â”‚   â”œâ”€â”€ cliSlice.js         # CLIçŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ skillSlice.js       # æŠ€èƒ½çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ sessionSlice.js     # ä¼šè¯çŠ¶æ€
â”‚   â”‚   â””â”€â”€ projectSlice.js     # é¡¹ç›®çŠ¶æ€
â””â”€â”€ services/
    â”œâ”€â”€ api.js                  # APIæœåŠ¡
    â”œâ”€â”€ ipc.js                  # IPCé€šä¿¡
    â””â”€â”€ storage.js              # å­˜å‚¨æœåŠ¡
```

### å…³é”®ç»„ä»¶å®ç°

#### 1. æŠ€èƒ½æ‰§è¡Œå™¨ç»„ä»¶
```jsx
import React, { useState } from 'react';
import { useCLI } from '../hooks/useCLI';

const SkillExecutor = ({ skill, onResult }) => {
  const [executing, setExecuting] = useState(false);
  const [progress, setProgress] = useState(0);
  const { executeSkill } = useCLI();

  const handleExecute = async () => {
    setExecuting(true);
    setProgress(0);

    try {
      const result = await executeSkill(skill.name, skill.params, {
        onProgress: (p) => setProgress(p)
      });
      
      onResult(result);
    } catch (error) {
      console.error('Skill execution failed:', error);
    } finally {
      setExecuting(false);
      setProgress(0);
    }
  };

  return (
    <div className="skill-executor">
      <h3>{skill.name}</h3>
      <p>{skill.description}</p>
      
      {executing && (
        <div className="progress">
          <div 
            className="progress-bar" 
            style={{ width: `${progress}%` }}
          >
            {progress}%
          </div>
        </div>
      )}
      
      <button 
        onClick={handleExecute} 
        disabled={executing}
        className="btn btn-primary"
      >
        {executing ? 'æ‰§è¡Œä¸­...' : 'æ‰§è¡ŒæŠ€èƒ½'}
      </button>
    </div>
  );
};
```

#### 2. è·¨CLIååŒç»„ä»¶
```jsx
import React, { useState } from 'react';
import { useCLI } from '../hooks/useCLI';

const CrossCLIExecutor = () => {
  const [command, setCommand] = useState('');
  const [targetCLI, setTargetCLI] = useState('claude');
  const [result, setResult] = useState(null);
  const { executeCrossCLI } = useCLI();

  const handleExecute = async () => {
    try {
      const executionResult = await executeCrossCLI(targetCLI, command);
      setResult(executionResult);
    } catch (error) {
      setResult({ success: false, error: error.message });
    }
  };

  return (
    <div className="cross-cli-executor">
      <h2>è·¨CLIååŒæ‰§è¡Œ</h2>
      
      <div className="form-group">
        <label>ç›®æ ‡CLI:</label>
        <select 
          value={targetCLI} 
          onChange={(e) => setTargetCLI(e.target.value)}
        >
          <option value="claude">Claude</option>
          <option value="qwen">Qwen</option>
          <option value="gemini">Gemini</option>
          <option value="iflow">iFlow</option>
        </select>
      </div>

      <div className="form-group">
        <label>å‘½ä»¤:</label>
        <textarea
          value={command}
          onChange={(e) => setCommand(e.target.value)}
          placeholder="è¾“å…¥è¦æ‰§è¡Œçš„å‘½ä»¤..."
          rows={4}
        />
      </div>

      <button onClick={handleExecute} className="btn btn-primary">
        æ‰§è¡Œ
      </button>

      {result && (
        <div className="result">
          <h3>æ‰§è¡Œç»“æœ:</h3>
          <pre>{JSON.stringify(result, null, 2)}</pre>
        </div>
      )}
    </div>
  );
};
```

---

## ğŸ”§ åç«¯è®¾è®¡

### ä¸»è¿›ç¨‹æ¶æ„ (ç»§æ‰¿Codeium Chatæ¶æ„)
```javascript
// main.js - ç»§æ‰¿Codeium Chatçš„ä¸»è¿›ç¨‹æ¶æ„
const { app, BrowserWindow, ipcMain } = require('electron');
const CodeiumChatApp = require('codeium-chat/src/main/app'); // ç»§æ‰¿Codeium Chatä¸»åº”ç”¨
const OpenInterpreterCLI = require('open-interpreter/src/cli'); // ç»§æ‰¿Open Interpreter CLI
const ContinuePluginSystem = require('continue/src/plugins'); // ç»§æ‰¿Continueæ’ä»¶ç³»ç»Ÿ

class StigmergyDesktopApp extends CodeiumChatApp {
  constructor() {
    super();
    // ç»§æ‰¿Codeium Chatçš„æ‰€æœ‰åŸºç¡€åŠŸèƒ½
    this.cliManager = new OpenInterpreterCLI(); // ç»§æ‰¿Open Interpreter CLI
    this.pluginSystem = new ContinuePluginSystem(); // ç»§æ‰¿Continueæ’ä»¶ç³»ç»Ÿ
    this.stigmergyManager = new StigmergyManager(); // æ–°å¢Stigmergyç®¡ç†å™¨
  }

  // ç»§æ‰¿Codeium Chatçš„çª—å£åˆ›å»º
  async createWindow() {
    // å®Œå…¨ä½¿ç”¨Codeium Chatçš„çª—å£åˆ›å»ºé€»è¾‘
    await this.createCodeiumChatWindow();
    
    // åˆå§‹åŒ–ç»§æ‰¿çš„ç³»ç»Ÿ
    await this.initializeInheritedSystems();
  }

  // åˆå§‹åŒ–ç»§æ‰¿çš„ç³»ç»Ÿ
  async initializeInheritedSystems() {
    // åˆå§‹åŒ–Open Interpreter CLI
    await this.cliManager.initialize();
    
    // åˆå§‹åŒ–Continueæ’ä»¶ç³»ç»Ÿ
    await this.pluginSystem.initialize();
    
    // åŠ è½½StigmergyæŠ€èƒ½ä½œä¸ºæ’ä»¶
    await this.pluginSystem.loadStigmergySkillsAsPlugins();
    
    // è®¾ç½®IPCé€šä¿¡
    await this.setupInheritedIPC();
  }

  // ç»§æ‰¿Codeium Chatçš„IPCè®¾ç½®ï¼Œæ–°å¢StigmergyåŠŸèƒ½
  async setupInheritedIPC() {
    // ç»§æ‰¿Codeium Chatçš„æ‰€æœ‰IPCå¤„ç†å™¨
    await this.setupCodeiumChatIPC();
    
    // ç»§æ‰¿Open Interpreterçš„IPCå¤„ç†å™¨
    await this.setupOpenInterpreterIPC();
    
    // ç»§æ‰¿Continueçš„IPCå¤„ç†å™¨
    await this.setupContinueIPC();
    
    // æ–°å¢Stigmergyç‰¹å®šçš„IPCå¤„ç†å™¨
    await this.setupStigmergyIPC();
  }

  // æ–°å¢Stigmergy IPCå¤„ç†å™¨
  async setupStigmergyIPC() {
    // Stigmergyå‘½ä»¤æ‰§è¡Œ
    ipcMain.handle('stigmergy:execute', async (event, { command, args }) => {
      return await this.stigmergyManager.executeCommand(command, args);
    });

    // è·¨CLIååŒ
    ipcMain.handle('stigmergy:cross-cli', async (event, { cli, skill, args }) => {
      return await this.stigmergyManager.executeCrossCLI(cli, skill, args);
    });

    // é¡¹ç›®ç®¡ç†
    ipcMain.handle('stigmergy:project-scan', async (event, projectPath) => {
      return await this.stigmergyManager.scanProject(projectPath);
    });

    // ä¼šè¯ç®¡ç†
    ipcMain.handle('stigmergy:session-create', async (event, sessionData) => {
      return await this.stigmergyManager.createSession(sessionData);
    });
  }
}

// å¯åŠ¨åº”ç”¨ (ç»§æ‰¿Codeium Chatå¯åŠ¨é€»è¾‘)
const stigmergyApp = new StigmergyDesktopApp();
app.whenReady().then(() => stigmergyApp.start());
```

### CLIç®¡ç†å™¨å®ç°
```javascript
// managers/cli-manager.js
const { spawn } = require('child_process');
const SafeExecutor = require('./safe-executor');
const path = require('path');

class CLIManager {
  constructor() {
    this.safeExecutor = new SafeExecutor();
    this.skillsPath = path.join(__dirname, '../skills');
    this.cliAdapters = this.loadAdapters();
  }

  loadAdapters() {
    return {
      'iflow': require('../adapters/iflow-cli-adapter'),
      'qwen': require('../adapters/qwen-cli-adapter'),
      'openskills': require('../adapters/openskills-universal-adapter')
    };
  }

  async executeCommand(command, args = []) {
    try {
      const result = await this.safeExecutor.execute(command, args);
      
      // è§£æä¸åŒå‘½ä»¤çš„è¿”å›ç»“æœ
      const parsedResult = this.parseCommandResult(command, result);
      
      return {
        success: true,
        command: command,
        args: args,
        result: parsedResult,
        rawOutput: result.stdout
      };
    } catch (error) {
      return {
        success: false,
        command: command,
        error: error.message
      };
    }
  }

  async executeCrossCLI(targetCLI, command) {
    try {
      // ä½¿ç”¨é€‚é…å™¨æ‰§è¡Œè·¨CLIè°ƒç”¨
      const adapter = this.cliAdapters[targetCLI];
      if (!adapter) {
        throw new Error(`CLI adapter for ${targetCLI} not found`);
      }

      const result = await adapter.execute(command);
      return {
        success: true,
        cli: targetCLI,
        command: command,
        result: result
      };
    } catch (error) {
      return {
        success: false,
        cli: targetCLI,
        command: command,
        error: error.message
      };
    }
  }

  async listSkills() {
    const skills = [];
    const skillFolders = await fs.readdir(this.skillsPath);

    for (const folder of skillFolders) {
      const skillPath = path.join(this.skillsPath, folder);
      const skillInfo = await this.analyzeSkill(skillPath);
      if (skillInfo) {
        skills.push(skillInfo);
      }
    }

    return skills;
  }

  async executeSkill(skillName, params) {
    // å¤ç”¨web_interface.pyçš„æŠ€èƒ½æ‰§è¡Œé€»è¾‘
    const skillPath = path.join(this.skillsPath, skillName);
    const scriptPath = path.join(skillPath, 'scripts', params.script);

    return await this.safeExecutor.execute('python', [
      scriptPath,
      ...this.buildScriptArgs(params)
    ]);
  }

  parseCommandResult(command, result) {
    // æ ¹æ®ä¸åŒå‘½ä»¤è§£æç»“æœ
    if (command === 'list') {
      return this.parseSkillList(result.stdout);
    } else if (command === 'status') {
      return this.parseStatus(result.stdout);
    } else {
      return { raw: result.stdout };
    }
  }
}
```

---

## ğŸ” å®‰å…¨è®¾è®¡

### å¤šå±‚å®‰å…¨æœºåˆ¶

#### 1. CLIè°ƒç”¨å®‰å…¨ (Open Interpreteræœºåˆ¶)
```javascript
class SecurityManager {
  constructor() {
    this.allowedCommands = new Set([
      'stigmergy', 'iflow', 'claude', 'qwen', 'gemini', 
      'codebuddy', 'codex', 'qodercli', 'python'
    ]);
    
    this.dangerousPatterns = [
      /rm\s+-rf/i,           // å±é™©åˆ é™¤å‘½ä»¤
      />\s*\/dev\/null/i,     // é‡å®šå‘åˆ°null
      /&&.*rm/i,             // é“¾å¼åˆ é™¤
      /\|\s*sh/i,            // ç®¡é“åˆ°shell
      /eval\s*\(/i,          // evalå‡½æ•°
      /exec\s*\(/i           // execå‡½æ•°
    ];
  }

  validateCommand(command, args) {
    // å‘½ä»¤ç™½åå•æ£€æŸ¥
    if (!this.allowedCommands.has(command)) {
      return {
        safe: false,
        reason: `Command '${command}' is not in the allowed list`
      };
    }

    // å‚æ•°å®‰å…¨æ£€æŸ¥
    for (const arg of args) {
      for (const pattern of this.dangerousPatterns) {
        if (pattern.test(arg)) {
          return {
            safe: false,
            reason: `Argument '${arg}' contains dangerous pattern`
          };
        }
      }
    }

    return { safe: true };
  }

  sanitizePath(filePath) {
    // è·¯å¾„å®‰å…¨æ£€æŸ¥ï¼Œé˜²æ­¢ç›®å½•éå†
    const normalizedPath = path.normalize(filePath);
    if (normalizedPath.includes('..')) {
      throw new Error('Path traversal detected');
    }
    return normalizedPath;
  }
}
```

#### 2. æ–‡ä»¶è®¿é—®å®‰å…¨
```javascript
class FileManager {
  constructor() {
    this.allowedExtensions = new Set([
      '.txt', '.md', '.json', '.csv', '.py', '.js', '.html', '.css'
    ]);
    
    this.maxFileSize = 10 * 1024 * 1024; // 10MB
    this.basePath = process.cwd(); // é™åˆ¶åœ¨å½“å‰å·¥ä½œç›®å½•
  }

  validateFile(filePath) {
    const fullPath = path.resolve(this.basePath, filePath);
    
    // æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸çš„è·¯å¾„å†…
    if (!fullPath.startsWith(this.basePath)) {
      throw new Error('File access denied: outside allowed directory');
    }

    // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
    const ext = path.extname(fullPath);
    if (!this.allowedExtensions.has(ext)) {
      throw new Error(`File type '${ext}' is not allowed`);
    }

    return fullPath;
  }

  async readFile(filePath) {
    const safePath = this.validateFile(filePath);
    
    const stats = await fs.stat(safePath);
    if (stats.size > this.maxFileSize) {
      throw new Error('File too large');
    }

    return await fs.readFile(safePath, 'utf8');
  }
}
```

#### 3. æ•°æ®åŠ å¯†å­˜å‚¨
```javascript
const crypto = require('crypto');

class SecureStorage {
  constructor() {
    this.algorithm = 'aes-256-gcm';
    this.secretKey = this.getOrCreateKey();
  }

  getOrCreateKey() {
    const keyPath = path.join(app.getPath('userData'), 'encryption.key');
    
    try {
      if (fs.existsSync(keyPath)) {
        return fs.readFileSync(keyPath);
      } else {
        const key = crypto.randomBytes(32);
        fs.writeFileSync(keyPath, key);
        return key;
      }
    } catch (error) {
      // å¦‚æœæ— æ³•åˆ›å»ºå¯†é’¥æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤å¯†é’¥
      return crypto.randomBytes(32);
    }
  }

  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.secretKey);
    cipher.setAAD(Buffer.from('stigmergy-app', 'utf8'));
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }

  decrypt(encryptedData) {
    const decipher = crypto.createDecipher(this.algorithm, this.secretKey);
    decipher.setAAD(Buffer.from('stigmergy-app', 'utf8'));
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–è®¾è®¡

### 1. å¯åŠ¨ä¼˜åŒ–
```javascript
class StartupOptimizer {
  constructor() {
    this.preloadTasks = [];
    this.criticalTasks = [];
  }

  async optimizeStartup() {
    // é¢„åŠ è½½å…³é”®ç»„ä»¶
    await this.preloadCriticalComponents();
    
    // å»¶è¿ŸåŠ è½½éå…³é”®ç»„ä»¶
    this.scheduleDelayedLoading();
    
    // ç¼“å­˜å¸¸ç”¨æ•°æ®
    await this.cacheFrequentData();
  }

  async preloadCriticalComponents() {
    // å¹¶è¡ŒåŠ è½½å…³é”®ç»„ä»¶
    await Promise.all([
      this.loadCLIAdapters(),
      this.loadBasicSkills(),
      this.initializeDatabase(),
      this.setupIPC()
    ]);
  }

  scheduleDelayedLoading() {
    // å»¶è¿ŸåŠ è½½éå…³é”®ç»„ä»¶
    setTimeout(() => this.loadAllSkills(), 1000);
    setTimeout(() => this.loadPluginSystem(), 2000);
    setTimeout(() => this.performHealthCheck(), 3000);
  }

  async cacheFrequentData() {
    // ç¼“å­˜å¸¸ç”¨æŠ€èƒ½å’Œé…ç½®
    const frequentSkills = await this.getFrequentSkills();
    await this.cacheSkills(frequentSkills);
    
    const cliConfigs = await this.getCLIConfigs();
    await this.cacheConfigs(cliConfigs);
  }
}
```

### 2. å†…å­˜ä¼˜åŒ–
```javascript
class MemoryManager {
  constructor() {
    this.cache = new Map();
    this.maxCacheSize = 100 * 1024 * 1024; // 100MB
    this.currentCacheSize = 0;
  }

  set(key, value) {
    const size = this.calculateSize(value);
    
    // æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ¶
    while (this.currentCacheSize + size > this.maxCacheSize) {
      this.evictLeastRecentlyUsed();
    }
    
    this.cache.set(key, {
      value,
      size,
      lastAccessed: Date.now()
    });
    
    this.currentCacheSize += size;
  }

  get(key) {
    const item = this.cache.get(key);
    if (item) {
      item.lastAccessed = Date.now();
      return item.value;
    }
    return null;
  }

  evictLeastRecentlyUsed() {
    let oldestKey = null;
    let oldestTime = Date.now();
    
    for (const [key, item] of this.cache) {
      if (item.lastAccessed < oldestTime) {
        oldestTime = item.lastAccessed;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      const item = this.cache.get(oldestKey);
      this.currentCacheSize -= item.size;
      this.cache.delete(oldestKey);
    }
  }
}
```

---

## ğŸ§ª æµ‹è¯•è®¾è®¡

### æµ‹è¯•æ¶æ„
```
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ managers/
â”‚   â”‚   â”œâ”€â”€ cli-manager.test.js
â”‚   â”‚   â”œâ”€â”€ file-manager.test.js
â”‚   â”‚   â””â”€â”€ security-manager.test.js
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ skill-executor.test.jsx
â”‚   â”‚   â”œâ”€â”€ cross-cli-executor.test.jsx
â”‚   â”‚   â””â”€â”€ project-tree.test.jsx
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ safe-executor.test.js
â”‚       â””â”€â”€ secure-storage.test.js
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ cli-integration.test.js
â”‚   â”œâ”€â”€ ipc-communication.test.js
â”‚   â””â”€â”€ plugin-system.test.js
â”œâ”€â”€ e2e/
â”‚   â”œâ”€â”€ skill-execution.test.js
â”‚   â”œâ”€â”€ cross-cli-collaboration.test.js
â”‚   â””â”€â”€ session-management.test.js
â””â”€â”€ performance/
    â”œâ”€â”€ startup-performance.test.js
    â”œâ”€â”€ memory-usage.test.js
    â””â”€â”€ cli-response-time.test.js
```

### å…³é”®æµ‹è¯•ç”¨ä¾‹

#### 1. CLIå®‰å…¨æ‰§è¡Œæµ‹è¯•
```javascript
// tests/unit/utils/safe-executor.test.js
describe('SafeExecutor', () => {
  let safeExecutor;

  beforeEach(() => {
    safeExecutor = new SafeExecutor();
  });

  describe('validate', () => {
    test('should allow valid commands', () => {
      expect(safeExecutor.validate('stigmergy', ['list'])).toEqual({
        safe: true
      });
    });

    test('should reject dangerous commands', () => {
      expect(safeExecutor.validate('rm', ['-rf', '/'])).toEqual({
        safe: false,
        reason: "Command 'rm' is not in the allowed list"
      });
    });

    test('should reject dangerous arguments', () => {
      expect(safeExecutor.validate('python', ['-c', 'rm -rf /'])).toEqual({
        safe: false,
        reason: "Argument '-c rm -rf /' contains dangerous pattern"
      });
    });
  });

  describe('execute', () => {
    test('should execute safe commands successfully', async () => {
      const result = await safeExecutor.execute('echo', ['hello']);
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('hello');
    });

    test('should timeout long-running commands', async () => {
      await expect(
        safeExecutor.execute('sleep', ['60'])
      ).rejects.toThrow('Command execution timeout');
    });
  });
});
```

#### 2. è·¨CLIååŒæµ‹è¯•
```javascript
// tests/integration/cli-integration.test.js
describe('CLI Integration', () => {
  let cliManager;

  beforeEach(() => {
    cliManager = new CLIManager();
  });

  test('should execute cross-CLI commands', async () => {
    const result = await cliManager.executeCrossCLI('claude', 'help');
    expect(result.success).toBe(true);
    expect(result.cli).toBe('claude');
  });

  test('should handle CLI adapter errors', async () => {
    const result = await cliManager.executeCrossCLI('nonexistent', 'command');
    expect(result.success).toBe(false);
    expect(result.error).toContain('not found');
  });
});
```

---

**æŠ€æœ¯è®¾è®¡æ–‡æ¡£åˆ¶å®šæ—¥æœŸ**: 2025å¹´12æœˆ20æ—¥  
**è®¾è®¡æ–‡æ¡£ç‰ˆæœ¬**: v7.0 (åŸºäºå®Œæ•´æœ¬åœ°åŒ–ï¼šå›¾å½¢åŒ–ç•Œé¢ + é¡¹ç›®ç®¡ç† + å®Œæ•´CLIé…ç½® + æœ¬åœ°AI/CLI/æŠ€èƒ½è°ƒç”¨)  
**é€‚ç”¨èŒƒå›´**: æœ¬åœ°åŒ–SubagentæŠ€èƒ½æ¡Œé¢åº”ç”¨é¡¹ç›®  
**æ ¸å¿ƒç­–ç•¥**: æ™ºèƒ½åŒ–å›¾å½¢ç•Œé¢ + é¡¹ç›®æ–‡ä»¶ç®¡ç† + å®Œæ•´CLIé…ç½®ç®¡ç† + æœ¬åœ°AI/CLI/æŠ€èƒ½è°ƒç”¨ + å®æ—¶åä½œæ”¯æŒ  
**æŠ€æœ¯åŸºç¡€**: Electronæ¡Œé¢åº”ç”¨ + æœ¬åœ°Stigmergyé›†æˆ + æœ¬åœ°æ–‡ä»¶æ“ä½œå™¨ + æœ¬åœ°CLIé…ç½®ç®¡ç†å™¨ + æœ¬åœ°å¤šAIé›†æˆæ¶æ„  
**é¡¹ç›®å®šä½**: é›¶CLIä¾èµ–çš„æœ¬åœ°åŒ–AIè¾…åŠ©å¼€å‘æ¡Œé¢åº”ç”¨  
**åº”ç”¨åœºæ™¯**: ç”¨æˆ·è¾“å…¥éœ€æ±‚ â†’ æœ¬åœ°AIå¤„ç† â†’ ç»“æœè¾“å‡º â†’ ç”¨æˆ·äº¤äº’ + é¡¹ç›®åˆ›å»º/æ–‡ä»¶ç¼–è¾‘ + å®Œæ•´é…ç½®ç®¡ç†  
**æ ¸å¿ƒä»·å€¼**: ç”¨æˆ·æ— éœ€æ¥è§¦å‘½ä»¤è¡Œå³å¯å®Œæˆæ‰€æœ‰æœ¬åœ°AIè¾…åŠ©å¼€å‘å·¥ä½œï¼ŒåŒ…æ‹¬é¡¹ç›®ç®¡ç†ã€æ–‡ä»¶æ“ä½œã€æ•°æ®å®Œå…¨æœ¬åœ°åŒ–  
**ä¸‹æ¬¡æ›´æ–°**: æ ¹æ®æœ¬åœ°æ–‡ä»¶æ“ä½œå™¨å¼€å‘è¿›å±•å’Œé¡¹ç›®ç®¡ç†åŠŸèƒ½æµ‹è¯•ç»“æœæ›´æ–°

---

*æœ¬æŠ€æœ¯è®¾è®¡æ–‡æ¡£åŸºäºå®Œæ•´æœ¬åœ°åŒ–åº”ç”¨åœºæ™¯ï¼Œç¡®ä¿é¡¹ç›®èƒ½å¤Ÿæä¾›å®Œæ•´çš„æœ¬åœ°åŒ–AIè¾…åŠ©å¼€å‘ç¯å¢ƒï¼Œå®ç°çœŸæ­£çš„æ•°æ®éšç§ä¿æŠ¤ã€é›¶CLIä¾èµ–å’Œå®Œæ•´çš„é¡¹ç›®ç®¡ç†åŠŸèƒ½ã€‚*